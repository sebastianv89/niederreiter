#ifndef NIEDERREITER_POLY_H
#define NIEDERREITER_POLY_H

#include "config.h"

/**!
 * Unless otherwise specified, polynomial operations are in the ring
 * GF(2)[x]/(x^r-1), where r = POLY_BITS.  From here on, we refer to
 * this modulus as the polynomial G.
 *
 * Polynomial representation: The lsb of each word holds the
 * coefficient of the lowest degree. Words with a higher index hold
 * represent higher degrees. For example, the two 8-bit word f with
 * f[0] = 0b00010011; f[1] = 0b00100000 represents the polynomial 1 +
 * x + x^4 + x^13.
 */

/** Enum for type of sparse polynomial generation */
enum sparse_type
{
    TYPE_POLY,
    TYPE_ERROR
};

/** f := 0 */
void poly_zero(
    word_t *f,
    size_t words);

/** f $= polynomial
 *
 * Generates a sparse polynomial with weight depending on \p type.
 *
 * The numbers are generated by rejection sampling. This is in
 * non-constant time, but it only leaks how many generated random
 * numbers were discarded, either because they were outside the
 * (publicly known) range or because there was a collision.
 */
void poly_gen_sparse(
    index_t *f,
    enum sparse_type type);

/** f (dense) := g (sparse)
 *
 * Convert sparse polynomial to dense polynomial.
 */
void poly_to_dense(
    word_t *f,
    const index_t *g);

/** f (dense) := g (sparse)
 * 
 * Convert sparse error to dense error. Aligns the dense error blocks
 * at `POLY_BITS` bits.
 * 
 * WARNING: Affects the value of g.
 */
void error_to_dense(
    word_t *f,
    index_t *g);

/** Verify that f == 0
 *
 * \return an error code: f == 0 ? 0 : -1
 */
int poly_is_zero(
    const word_t *f, size_t words);

/** \return hamming weight of f */
word_t poly_hamming_weight(
    const word_t *f);

/** f = g & h */
void poly_mask(
          word_t *f,
    const word_t *g,
    const word_t *h);

/** f := f^T
 *
 * A polynomial does not really have a transpose, but this operation
 * corresponds to transposing the matrix that is represented by the
 * polynomial.
 */
void poly_transpose(index_t *f);

/** f += g & mask */
void poly_add_masked(
          word_t *f,
    const word_t *g,
          word_t mask);

/** f *= x mod G */
void poly_inplace_mul_x_modG(
    word_t *f);

/** f := g + h */
void poly_add(
          word_t *f,
    const word_t *g,
    const word_t *h,
          size_t words);

/** f[bit_index] ^= bit
 *
 * \warning The parameter \p bit_index MUST NOT be a secret value,
 * because that would make the implementation vulnerable to a
 * cache-based sidechannel attack.
 */
void poly_flip(
    word_t *f,
    index_t bit_index,
    word_t bit);

/** f := g * h */
void poly_mul(
          word_t *f,
    const word_t *g,
    const word_t *h);

/** f := g * h */
void poly_sparse_mul(
          word_t *f,
    const word_t *g,
    const index_t *h);

/** f := f^{-1}
 *
 * \return error code: 0 on success, -1 on failure
 */
int poly_inv(word_t *f);

#endif /* NIEDERREITER_POLY_H */
